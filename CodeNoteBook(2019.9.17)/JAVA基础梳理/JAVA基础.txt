1.重写（@Override）和重载（@Overload）
①。重写是对于类之间继承关系来说的，A类继承B类，在A里对继承的方法进行修改，叫做重写，子方法的方法名，参数列表必须与父类相同，且返回值范围，抛出的异常范围要小于父类，访问修饰符范围要大于父类，如果父类方法的访问修饰符是private则子类不能重写该方法。
②。重载是对于同一个类中的方法，方法名必须相同，参数个数不同，类型不同，顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。

2.String和StringBuffer,StringBuild的区别是什么，String为什么不可变。
String对象是不可变的，也可以理解为常量，线程安全，每次对String类型进行改变的时候都会新建一个String对象，然后将指针指向新的String对象。
StringBuffer和StringBuild有着公共父类AbstractStringBuild，它定义了一些字符的基本操作，如expendCapacity，append，insert，indexOf等公共方法。StringBuffer对方法加了同步锁或者对其调用的方法加了同步锁，是线程安全的，StringBuild没有加同步锁，不是线程安全的。StringBuffer和StringBuild每次操作都是对其对象本身进行操作，相同情况下StringBuild相比StingBuffer能获得10-15%的性能提升，但牺牲了多线程安全。
String类中使用final关键字字符数组保存字符串，private final char value[]，所以String对象是不可变的。

3.自动装箱和拆箱
装箱：将基本数据类型用他们的引用类型包装起来；
拆箱：将包装类型转换为基本数据类型。

4.==与equals
==：它的作用是判断两个对象的地址是不是相等，即判断两个对象是不是同一个对象（基本数据类型比较的值，引用数据类型比较的是内存地址）

equals():它的作用是判断两个对象是否相等，但它一般有两种使用情况：
情况1：类没有覆盖equals（）方法，则通过equals（）比较该类的两个对象时，等价于“==”比较这两个对象。
情况2：类覆盖了equals（）方法，一般我们都覆盖equals()方法的两个对象的内容是否相等，如内容相等，则返回true（即认为两个对象相等）。
说明：1.String中的equals()方法是被重写过的，所以object的equals是比较对象的物理地址，而String的equals比较的是对象的值。
2。当创建String类型的对象是，虚拟机会在常量池查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用，如果没有就在常量池里新建一个String对象。

5.关于final
final可以作用的方法：变量，方法，类
①.作用在变量时，如果是基本数据类型，则其数值一旦初始化话就不能被修改，如果是引用类型则在初始化后便不能让其指向另一个对象。
②.当final作用于一个类时，则该类不能被继承，且类里的所有成员方法都会被隐式地指定为final方法。
③.使用final方法的原因有两个：第一是把方法锁定，以防任何继承类修改它的含义，第二是效率（现在已经不用这种方法优化了）。类中所有的private方法都隐式地指定为final.

6.Object方法的常用方法
getclass:返回当前运行对象的class对象，使用了final修饰，不能重写；
hashcode：返回对象的哈希码；
equal：用于比较两个对象的内存地址是否相等，String类对其进行了重写比较字符串的值是否相等；
clone：用于创建并返回对象的一份拷贝；
toString：返回类名字@实例的hash码的16进制字符串，建议object所有之类都重写该方法
notify：唤醒等待的线程
notifyall：唤醒对象监视器上等待的所有线程。
wait（long timeout）：暂停线程的执行，timeout为等待时间（long timeout，int nanos）多了的参数表示额外时间，超时的时间还要加上nanos毫秒
wait（）：无参数表示一直等待
finalize：实例被垃圾回收器回收的时候触发的操作。

7.JAVA中的异常Error和Exception
在java中，所有的异常都有一个共同的祖先java.lang包下的Throwable类，该类下有两个重要的子类Exception（异常）和Error（错误）。二者都是java异常处理的重要子类，各自都包含大量子类。
Error（错误）:是程序无法处理的异常，大多数错误与代码编写组执行的操作无关，是代码运行时jvm出现的问题，如内存溢出（OutOfMemoryError）,类定义错误（NoClassFoundError）,这些错误时不可查的，因他们在应用程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。
Exception（异常）：是程序本身可以处理的错误。Exception有一个重要的之类RunTimeException。RunTimeException异常有jvm抛出，NullPointerException（要访问的变量没有引用任何对象时，抛出该异常）、ArithmeticException（算数运行异常，一个整数除以0时抛出该异常）和ArrayIndexOutOfBoundsException（下标越界异常）。
注意：异常与错误直接的区别在于异常能被程序本身处理，错误无法处理。
trycatchfinally可以对异常进行捕捉和处理，finally一般都会被执行
在以下4中情况下finally块不会被执行：
1.在finally语句块中出现了异常，2.在前面的代码中用了System.exit()退出程序，
3.线程所在的线程死亡，4.关闭cpu

8.获取键盘输入的常用两种方法：
Scanner：Scanner input = new Scanner(System.in);
String s =input.netLine();
input.close();

BufferedReader:BufferedReader input = new BufferedReader(new InputStreamReader(System.in));
String s= inout.readLine();

9.静态代理和动态代理
静态代理的代理对象创建在代码运行前，即在代理类实现时就指定与目标对象类）（RealSubject）相同的接口。一般用于代理单一目标对象；
动态代理代理对象的创建是在运行时，不需要显式实现与目标对象类（RealSubject）相同的接口，而是讲这种实现推迟到程序运行时有jvm来实现，底层实现原理是反射，效率低，一般用于代理多个目标对象。

10.接口和抽象类的区别
①。接口的方法默认是public，所有方法在接口中不能有实现（java8开始接口方法可以有默认实现），抽象类可以有非抽象的方法；
②。接口中的实例变量默认是final类型的，而抽象类中的不一定；
③。一个类可以实现多个接口，但最多只能实现一个抽象类；
④。一个类实现接口的话必须实现接口的所有方法，二抽象类不一定；
⑤。接口不能new，但可以声明，同时必须引用一个实现了该接口的对象，从设计层面讲抽象是对类的抽象，是一种模板设计，接口是对行为的抽象，是一种行为的规范。
备注：在java8中，接口也可以定义静态方法，可以直接用接口名调用，实现类和实现是不可以调用的。如果同时实现了两个接口，接口中定义了一样的默认方法，必须重写，不然会报错。

interface的应用场合
类与类之前需要特定的接口进行协调，而不在乎其如何实现。
作为能够实现特定功能的标识存在，也可以是什么接口方法都没有的纯粹标识需要将一组类视为单一的类，而调用者只通过接口来与这组类发生联系。
需要实现特定的多项功能，而这些功能之间可能完全没有任何联系。

 abstract class的应用场合
一句话，在既需要统一的接口，又需要实例变量或缺省的方法的情况下，就可以使用它。最常见的有：
定义了一组接口，但又不想强迫每个实现类都必须实现所有的接口。可以用abstract class定义一组方法体，甚至可以是空方法体，然后由子类选择自己所感兴趣的方法来覆盖。
某些场合下，只靠纯粹的接口不能满足类与类之间的协调，还必需类中表示状态的变量来区别不同的关系。abstract的中介作用可以很好地满足这一点。
规范了一组相互协调的方法，其中一些方法是共同的，与状态无关的，可以共享的，无需子类分别实现；而另一些方法却需要各个子类根据自己特定的状态来实现特定的功能


11.java集合框架之ArrayList和LinkedList异同：
①。线程安全：ArrayList和LinkedList都是不同步的，都不保证线程安全
②。底层数据结构：ArrayList采用的是Object数组，LinkedList采用的是双向链表数据结构（jdk1.6前为循环链表，1.7取消了循环）。
③。插入和删除是否受元素位置的影响：
ArrayList采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。
LinkedList采用链表存储，所以插入和删除元素时间复杂度不受元素位置影响，都是近似哦（1），而数组为近似哦（n);
④。是否支持快速随机访问：LinkedList不支持而ArrayList支持。
⑤。内存空间的占用：ArrayList的空间浪费主要体现在list列表的结尾会预留一定的容量空间而LinkedList的空间话费则体现在他每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接前驱和直接后以及数据）。

12.ArrayList和Vector的区别
ArrayList是不同步的，线程不安全，且每次扩容都是增加50%
Vector是同步的即线程安全的，每次扩容为增加一倍。

13.HashMap的底层实现时数组和链表相结合，也就是链表散列，并且通过拉链法解决冲突
拉链法：将链表与数组相结合，也就是说创建一个链表数组，数组中每一格就是一个链表，若遇到哈希冲突，则将冲突的值加到链表中即可。
在jdk1.8后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认8）时，将链表转换为红黑树，以减少搜索时间。

14.HashMap和HashTable的区别
1.线程是否安全：HashMap是异步的，线程不安全，如果要保证线程安就是用ConCurrentHashMap)。HashTable是同步的，线程安全.
2.效率：由于线程安全问题。HashMap要比HashTable效率高，且HashTable基本淘汰不用
3.对Null key和null value的支持：HashMap支持放入唯一一个Null key，但是可以有多个value为null，HashTable不支持null key，有就抛出异常；
4.初始容量大小和扩容大小：hashtable默认为11，每次扩容为2n+1，且如果设置初始值就直接用设置的值作为初始大小，hashmap默认为16，每次扩容为2n，且如果有设置初始大小，则把初始值扩大到2的幂次方在将其作为初始大小（该特效通过hashmap的tableSizeFor（）方法保证）。
5.底层数据结构：jdk1.8后hashmap在解决hash冲突时有了较大变化，当链表长度大于阈值（默认8）时将转换为红黑树减少搜索时间，hashtable没有这样的机制。hashTable是基于陈旧的dictionary类。

15.HashMap死循环问题
在进行扩容时，可能会出现此问题。将A复制到hash表中，节奏复制B到链头（A的前边，B.next=A），本来B.next=null到这就结束了，但由于线程而扩容的原因，将B.next=A，所以这里继续复制A，让A.next=B,由此形成环形链表，出现死循环。jdk1.8已解决此问题。

16.HashSet和HashMap的区别
HashSet底层是基于HashMap实现的
HashMap实现了Map接口，HashSet实现的是Set接口；
HashMap存储键值对，HashSet仅存储对象；
hashMap用put（）向map中添加元素，HashSet用add（）添加元素；
HashMap使用key来计算hashcode，HashSet使用成员变量来计算hashcode，对于两个code来说hashcode可能相同，所以equals（）方法用来判断对象的相等性，如果两个对象不同就返回false；
HashMap比HashSet快，因为他是使用唯一的键来获取对象。
HashSet不能有重复的元素，HashMap可以有重复的Value不能有重复的Key



17.双层校验锁实现对象实例（线程安全）
public class singleton{
private volatile static Singleton uniqueInstance

private Singleton(){}

public static Singleton getUniqueInstance(){
//判断对象是否已经实例化，没有实例化才进入加锁代码
if(uniqueInstance == null){
synchronized(Singleton.class){
if(uniqueInstance==null){
uniqueInstance = new Singleton();
}
}
}
return uniqueInstance;
}
}
对uniqueInstance采用volatile关键字修饰很有必要，可以禁止jvm的指令重排，保证多线程环境下的运行正常。


synchronized和lock的区别
①.synchronized是java关键字，jvm层面的锁，lock是一个java类
②.synchronized可重入，不可中断，非公平的，lock可重入，可中断，可公平
③.synchronized无法判断是否获取锁的状态，lock可以判断是否获得锁
④.synchronized会自动释放锁（执行完或执行时发生异常都会释放），而lock不会自动释放，需在finally中手动释放锁（使用unlock（）方法），否则容易发生死锁
⑤.synchronized修饰的如果线程1获得锁线程2会等待，如果线程1阻塞线程2会一直等待，而lock如果线程1阻塞线程2尝试活不到锁不用一直等待就结束了
⑥.synchronized适合代码少量的同步问题，lock适合大量代码同步的问题。

18.线程池之为什么使用线程池
①。降低资源消耗：通过利用已创建的线程来降低线程创建和销毁带来的消耗，
②。提高响应速度：当任务到达时可以直接用已创建好的线程执行，无需等待
③。提高线程的可管理性：线程是稀缺资源，如果无限制的创建不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

19.tcp与udp的区别：
tcp面向连接，传说可靠，通过字节流形式传输，效率低，所需资源多，多用于文件传输或邮件传递，首部字节为20-60；
udp传输不可靠，通过数据报文段传输，效率高，消耗资源少，多用于即时通讯如qq语言视频或直播，首部字节为8。

20.在地址栏输入一个url地址到显示主页的过程
①浏览器查找域名的ip地址（dns查找过程：浏览器缓存，路由器缓存，dns缓存）
②.浏览器向web服务器发送一个HTTP请求（cookies会一并发送给服务器）
③。服务器处理请求（请求处理请求和参数，cookies，生成一个html响应）
④.服务器发回一个html响应
⑤。浏览器开始显示html



21.Mysql之两个存储引擎MyISAM与InnoDB
count运算上有区别，MyISAM强调的是性能，每次查询具有原子性，执行更快，但不支持事务，innodb支持事务，且有外部键等高级数据库功能，具有事务提交，回滚和奔溃修复能力的事务安全型表。
MyISAM更适合读密集的表，而InnoDB更适合写密集的表。


22.数据库索引：
为什么使用索引：通过创建唯一性的索引可以保证数据库表中每一行数据的唯一性，可以大大加快数据的检索速度（通过大大减少检索量），帮助服务器避免排序和临时表，将随机IO变为顺序io，加快表与表之间的连接，实现数据的参考完整性。 

为什么不对表中的每一列创建一个索引：对表中的数据进行增加删除和修改时，索引也要动态的维护，会降低数据的维护速度。而且索引也需要占用物理空间，如果要建立集蔟索引的话所需的空间会更大，创键和维护索引都需要耗费时间，这种时间随着数据量的增加而增加。

索引如何提高速度：通过将无序的数据变成相对有序的数据（相当于查目录）

使用索引的注意事项：在经常需要搜索的列上加索引，在经常使用WHERE子句的列上创建索引可以加快条件的判断速度，在需要经常排序的类上加索引，这样可以通过索引提前拍好序，索引对中大型表很有效，但不适合特大型表。在经常用在连接得列上可以加索引，通常是外键，可以加快连接速度。将打算加索引的列设置为NOT NULL,使用索引可以提升limit offset查询的速度



23.事务
事物的特性：原子性，一致性，隔离性，持久性
并发给事务带来的问题：脏读，幻读，不可重复读和丢失修改
事务隔离级别：read-uncommited未提交读，会导致脏读，幻读和不可重复读
read-conmited提交读，能解决脏读，但还会存在幻读不可重复读，是oracle数据库默认的事务隔离级别
repeatable-read重复读，能解决脏读和不可重复读，但还会存在幻读，是mysql数据库默认的事务隔离级别
serializable可串行化，完全浮沉acid的隔离级别，能防止脏读幻读和不可重复读，但是效率低

24.Spring的事务传播行为：
支持当前事务的情况：
TransactionDefinition.propagation_Required:如果当前存在事务，则加入该事务，如果不存在则新建一个事务；
supports：如果当前存在事务，则加入，如果不存在则不用事务
mandatory：如果当前存在事务，则加入。不存在则抛出异常
不支持当前事务的情况
Required_new：如果当前存在事务，则挂起，新建一个事务
not_supported:不使用事务，即使如果当前存在事务，也挂起，不使用事务
never：以非事务方式运行，当前存在事务则抛出异常。
嵌套事务：
nested：如果当前存在事务则创建一个事务作为当前事务的嵌套来运行，如果没有事务则等价于required。